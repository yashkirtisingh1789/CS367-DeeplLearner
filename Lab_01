import time
from collections import deque

# start state
start_state = ('E', 'E', 'E', 'O', 'W', 'W', 'W')
# goal state
goal_state = ('W', 'W', 'W', 'O', 'E', 'E', 'E')

def is_valid(new_index, state):
    return 0 <= new_index < len(state)

def get_successors(state):
    """Generates all valid next states based on the Rabbit Leap rules."""
    successors = []
    empty_index = state.index('O')
    state_list = list(state)

    # --- Check for East-bound ('E') rabbit moves (they move right) ---

    # Case 1: 'E' slides right into an empty space (e.g., E O -> O E)
    if empty_index > 0 and state[empty_index - 1] == 'E':
        new_state = state_list[:]
        new_state[empty_index], new_state[empty_index - 1] = new_state[empty_index - 1], new_state[empty_index]
        successors.append(tuple(new_state))

    # Case 2: 'E' jumps right over another rabbit (e.g., E W O -> O W E)
    if empty_index > 1 and state[empty_index - 2] == 'E':
        new_state = state_list[:]
        new_state[empty_index], new_state[empty_index - 2] = new_state[empty_index - 2], new_state[empty_index]
        successors.append(tuple(new_state))

    # --- Check for West-bound ('W') rabbit moves (they move left) ---

    # Case 3: 'W' slides left into an empty space (e.g., O W -> W O)
    if empty_index < 6 and state[empty_index + 1] == 'W':
        new_state = state_list[:]
        new_state[empty_index], new_state[empty_index + 1] = new_state[empty_index + 1], new_state[empty_index]
        successors.append(tuple(new_state))

    # Case 4: 'W' jumps left over another rabbit (e.g., O E W -> W E O)
    if empty_index < 5 and state[empty_index + 2] == 'W':
        new_state = state_list[:]
        new_state[empty_index], new_state[empty_index + 2] = new_state[empty_index + 2], new_state[empty_index]
        successors.append(tuple(new_state))
        
    return successors

# Implementing bfs
def bfs(start_state, goal_state):
    queue = deque([(start_state, [])])
    visited = set()
    max_queue_size = 1
    
    while queue:
        (state, path) = queue.popleft()
        if state in visited:
            continue
        visited.add(state)
        path = path + [state]
        
        if state == goal_state:
            return path, len(visited), max_queue_size
        
        for successor in get_successors(state):
            queue.append((successor, path))
        max_queue_size = max(max_queue_size, len(queue))  
    
    return None, 0, 0

# Implementing dfs  
def dfs(start_state, goal_state):
    queue = [(start_state, [])]
    visited = set()
    max_queue_size = 1  
    
    while queue:
        (state, path) = queue.pop()
        if state in visited:
            continue
        visited.add(state)
        path = path + [state]
        
        if state == goal_state:
            return path, len(visited), max_queue_size
        
        for successor in get_successors(state):
            queue.append((successor, path))
        max_queue_size = max(max_queue_size, len(queue))  
    
    return None, 0, 0


# Finding solution using bfs
start_time_bfs = time.time() # --- ADDED ---
solution_bfs, visited_length_bfs, max_queue_size_bfs = bfs(start_state, goal_state)
end_time_bfs = time.time() # --- ADDED ---
execution_time_bfs = end_time_bfs - start_time_bfs # --- ADDED ---

print("Using BFS: ")
print("Total Number of operations:", len(solution_bfs) - 1 if solution_bfs else 0)
print("Maximum queue size:", max_queue_size_bfs)
print("Number of visited nodes:", visited_length_bfs)
print(f"Execution Time: {execution_time_bfs:.6f} seconds") # --- ADDED ---
print()

if solution_bfs:
    print("Solution found:")
    for step in solution_bfs:
        print(step)
else:
    print("No solution found.")
    

print("-----------------------------------------------")

# Finding solution using dfs
start_time_dfs = time.time() # --- ADDED ---
solution_dfs, visited_length_dfs, max_queue_size_dfs = dfs(start_state, goal_state)
end_time_dfs = time.time() # --- ADDED ---
execution_time_dfs = end_time_dfs - start_time_dfs # --- ADDED ---

print("Using DFS: ")
print("Total Number of operations:", len(solution_dfs) - 1 if solution_dfs else 0)
print("Maximum queue size:", max_queue_size_dfs)
print("Number of visited nodes:", visited_length_dfs)
print(f"Execution Time: {execution_time_dfs:.6f} seconds") # --- ADDED ---
print()

if solution_dfs:
    print("Solution found:")
    for step in solution_dfs:
        print(step)
else:
    print("No solution found.")
